--------------------------------
| Data Structures & Algorithms |
--------------------------------

=: Java Basics :=
-----------------
=> Java File:-
-> file extention : .java
-> Main public Class Name and file name should match
-> to run java file main public Class should have main() method
-> Boilerplate Code:-

    class ClassName {
      public static void main(String[] args) {
            // Code
     }
    }

=> Output in java:-
-> Output using print() function
-> println() for next line after printing output 

    System.out.println("Hello, World!");

    Output:-
    Hello, World!   
 
 => Variables in java:-
 -> Variables are containers for storing data values.

In Java, there are different types of variables, for example:

String - stores text, such as "Hello". String values are surrounded by double quotes
int - stores integers (whole numbers), without decimals, such as 123 or -123
float - stores floating point numbers, with decimals, such as 19.99 or -19.99
char - stores single characters, such as 'a' or 'B'. Char values are surrounded by single quotes
boolean - stores values with two states: true or false

=> Data Types in java:-
-> java is a typed language. We need to define variables type in declaration.
-> there are two types of daya type in java : 
 1. Primitive Data Types :
    - byte (1 byte)
    - short (2 byte)
    - char (2 byte)
    - boolean (1 byte)
    - int (4 byte)
    - long (8 byte)
    - float (4 byte)
    - double (8 byte)
Note: 1 byte = 8 bit
    bit = 0 or 1

byte - Stores whole numbers from -128 to 127 (without decimals).
short - Stores whole numbers from -32,768 to 32,767 (without decimals).
char - stores single characters, such as 'a' or 'B'. Char values are surrounded by single quotes.
boolean - stores values with two states: true or false.
int - stores integers (whole numbers) from -2,147,483,648 to 2,147,483,647 (without decimals)
long - stores integers (whole numbers), from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (without decimals), Note that you should end the value with an "L".
float - stores floating point numbers, with decimals, such as 19.99f or -19.99f , Sufficient for storing 6 to 7 decimal digits, Note that you should end the value with an "f".
double - stores floating point numbers, with decimals, such as 19.99 or -19.99 , Sufficient for storing 15 to 16 decimal digits, Note that you should end the value with an "d".

 2. Non-Primitive Data Type :
    - String
    - Array
    - Class
    - Object
    - Interface

String - stores text, such as "Hello". String is a arrya of characters ,values are surrounded by double quotes.
Array - Arrays are used to store multiple values of same data type in a single variable, instead of declaring separate variables for each value.
        To declare an array, define the variable type with square brackets [ ].
Class - A Class is like an object constructor, or a "blueprint" for creating objects.
Objects - object is created from a class.
Interface - An interface is a completely "abstract class" that is used to group related methods with empty bodies.

=> Comments in java:-
-> Single Line Comment: // for single line comments.
    // single line comment
-> Multiline Comment : /* */ for multiline comments.
    /* multiline comment */
->Doc Type Comment : A doc comment starts with /**  and ends with */
    /**
    * A brief description of the class.
    *
    * More detailed description can go here.
    * The first sentence is used as a summary.
    * <p>Use HTML tags for formatting, like paragraphs.</p>
    *
    * @author  Author Name
    * @version 1.0
    */

=> Input in Java:-
-> The Scanner class is used to get user input, and it is found in the java.util package.
    Scanner sc = new Scanner(System.in);
    Explanation : Scanner -> class
                  sc -> object of Scanner class (in this case "sc" is used it can be anything )
                  new -> key word used to create Objects.
                  Scanner(System.in) -> Scanner class takes argument - System.in
                  System.in -> - System class
                               - "in" is a object of System class

-> nextLine() method used to take one Line input.
    String name = sc.nextLine();
       Explanation : String -> String is a class used to store string(array of characters)
                     name -> name is a object of String class (in this case "name" is used it can be anything)
                     sc -> object of Scanner class (we have created above - in this case "sc" is used it can be anything )   
                     nextLine() -> nextLine() is a method of Scanner class

-> Scanner class has different methods for different data types :
    next() ->  Reads a Single word from the user
    nextLine()	-> Reads a String value from the user
    nextByte()	-> Reads a byte value from the user
    nextShort()	-> Reads a short value from the user
    nextBoolean() -> Reads a boolean value from the user
    nextInt() -> Reads a int value from the user
    nextFloat() -> Reads a float value from the user
    nextLong() -> Reads a long value from the user
    nextDouble() -> Reads a double value from the user

=> Type Conversion:-
-> Java automatically make conversion.
-> Type Conversion happens when:
    - type compatible
    - destination type > source type

-> Widening Conversion or Implicit Conversion (automatic) - converting a smaller type to a larger type size

    byte -> short -> char -> int -> long -> float -> double
-> example : 
    int a = 10;
        long b = a; // conversion successful

        long c = 10;
        int d = c; // compilation error
        /* 
        * reason: possible loss of information
        * when converting from a larger data type to a smaller data type
        * in this Case : long(8 byte) > int(4 byte)
        * solution: explicit casting
        */ 


        System.out.println("b : "+b);
        System.out.println("d : "+d);    

=> Type Casting:-
-> Java can't make conversion automatically, we have to manually cast type.
-> Narrowing Casting or explicit Conversion(manual) - converting a larger type to a smaller type size

    double -> float -> long -> int -> char -> short -> byte
-> example :
    float x = 9.78f; 
          int y =  x; // compilation error: incompatible types: possible lossy conversion from float to int
        /**
         * -> reason: possible loss of information
         * -> when converting from a larger data type to a smaller data type
         * -> in this Case : float(4 byte) > int(4 byte)
         * -> solution: explicit casting
         */
        int y = (int) x; // explicit casting from float to int

        System.out.println("x : " + x);
        System.out.println("y : " + y);

=> Special Case Conversion:-
-> when try to converting characters to numbers it converting into character's ASSCI value.
-> example :  
    char character = 'A';

        // Implicit conversion from char to int
        int intValue = character;
        System.out.println("Character: " + character);
        System.out.println("Integer value (implicit conversion): " + intValue);

        // Explicit conversion from char to int
        int explicitIntValue = (int) character;
        System.out.println("Integer value (explicit conversion): " + explicitIntValue);

=> Type Promotion in Expressions:-
-> java automatically promotes each byte, short or char operand into int when evaluating an Expressions.
-> if one operand is long, float or double the whole Expression is promoted to long, float or double respectively.  
-> example :
     byte b1 = 10;
        byte b2 = 20;
        // byte b3 = b1 + b2; // Compilation error: cannot convert from int to byte

        int i1 = 100;
        int i2 = 200;
        int i3 = i1 + i2; // Valid

        float f1 = 5.5f;
        float f2 = 4.5f;
        float f3 = f1 + f2; // Valid

        double d1 = 10.5;
        double d2 = 20.5;
        double d3 = d1 + d2; // Valid

        // Mixed type expression
        double result = b1 + i1 + f1 + d1; // All operands promoted to double
        /**
         * Explanation :
         * 1. When performing arithmetic operations, Java promotes smaller data types to larger data types
         * 2. In mixed-type expressions, all operands are promoted to the largest data type involved in the expression
         */
        System.out.println("Result of mixed type expression: " + result);

=> How Java Code run:-
-> Java Development Kit(JDK) consist Java Run-Time Environment(JRE) + Development Tools.
-> Java Run-Time Environment(JRE) consist Java Virtual Machine(JVM) + Libraries.
-> Flow of running java code:

    source code ---> compiler ---> byte code ---> Java Virtual Machine ---> native code
    .java            compilation     .class             JVM                      
                                                        (Ecxecution)

-> Portable language, once compiler compile code it(.class) can run at any platform(Operating System).

=> Operators:-
-> Symbols that tell compiler to perform some operations.
-> types of operator in java :
    1. Arithmetic Operators (Binary/Unary/ternary): 
        - Binary : + , - , * , / , %
        - Unary : ++ , --
        - example : 
         /* Binary Operators */
        int a = 10;
        int b = 5;

        // Addition
        int addition = a + b;
        System.out.println("Addition: " + addition);

        // Subtraction
        int subtraction = a - b;
        System.out.println("Subtraction: " + subtraction);

        // Multiplication
        int product = a * b;
        System.out.println("Product: " + product);

        // Division
        int division = a / b;
        System.out.println("Division: " + division);

        // Modulus
        int remainder = a % b;
        System.out.println("Remainder: " + remainder);

          /* Unary Operators */
          int x = 10;
          int y = 5;

        // Unary Plus
        ++x; // Pre-Increment x by 1
        System.out.println("Unary Plus(Pre-Increment): " + x);
        x++; // Post-Increment x by 1
        System.out.println("Unary Plus(Post-Increment): " + x);

        // Unary Minus
        --y; // Pre-Decrement y by 1
        System.out.println("Unary Minus(Pre-Decrement): " + y);
        y--; // Post-Decrement y by 1
        System.out.println("Unary Minus(Post-Decrement): " + y);

        /*ternary Operator */
        int num1 = 10;
        int num2 = 20;

        // Ternary Operator
        int max = (num1 > num2) ? num1 : num2;
        System.out.println("Maximum: " + max);

         /**
         * Note:
         * The ternary operator is a shorthand for an if-else statement.
         * It takes three operands: a condition, a result for true, and a result for false.
         * Syntax: condition ? expression1 : expression2;
         * If the condition is true, expression1 is evaluated and returned; otherwise, expression2 is evaluated and returned.
         */

    2. Relational Operators : == , != , > , < , >= ,<= 
        - Relational operators are used to compare two values (or variables).
        - The return value of a comparison is either true or false.
        - example :
        int a = 10;
        int b = 20;

        // Using relational operators
        System.out.println("a < b: " + (a < b));   // true
        System.out.println("a > b: " + (a > b));   // false
        System.out.println("a <= b: " + (a <= b)); // true
        System.out.println("a >= b: " + (a >= b)); // false
        System.out.println("a == b: " + (a == b)); // false
        System.out.println("a != b: " + (a != b)); // true

    3. Logical Operators: && (Logical AND), || (Logical OR), ! (Logical NOT)
    - Logical operators are used to determine the logic between variables or values, by combining multiple conditions.
    - As with Relational operators, you can also test for true or false values with logical operators.
    logic table:-
    - for Logical AND:
    --------------------------------------
    | condition 1 | condition 2 | Answer |    
    --------------------------------------
    |     true    |   true      |  true  | 
    |     true    |   false     |  false | 
    |     false   |   true      |  false | 
    |     false   |   false     |  false |
    --------------------------------------
    - for Logical OR:
    --------------------------------------
    | condition 1 | condition 2 | Answer |    
    --------------------------------------
    |     true    |   true      |  true  | 
    |     true    |   false     |  true  | 
    |     false   |   true      |  true  | 
    |     false   |   false     |  false |
    --------------------------------------
    - for Logical NOT:
    -------------------------
    |  condition | Answer  |    
    -------------------------
    |    true    |   false |
    |    false   |   true  |
    -------------------------
    
    - example :
       int a = 10;
        int b = 20;
        System.out.println("Values: a = " + a + ", b = " + b);
        // Using logical AND operator
        if (a < 15 && b > 15) {
            System.out.println("logical AND operator: a < 15 && b > 15");
            System.out.println("Both conditions are true.");
        }
        // Using logical OR operator
        if (a < 5 || b > 15) {
            System.out.println("logical OR operator: a < 5 || b > 15");
            System.out.println("At least one condition is true.");
        }
        // Using logical NOT operator
        if (!(a > 15)) {
            System.out.println("logical NOT operator: !(a > 15)");
            System.out.println("Condition is false, so NOT operator makes it true.");
        }

    4. Bitwise Operators : & (Bitwise AND), | (Bitwise OR), ^ (Bitwise XOR), ~ (Bitwise NOT), << (Left shift), >> (Right shift)
    - A bitwise operator is a symbol or keyword that tells the computer what operation to perform, bit by bit, on values or variables.
    - Bitwise operators are used to perform operations on values or variables, one bit at a time.
    - All data in the computer is stored as sequences of 0s and 1s. This makes it possible to use bitwise operators to manipulate the data.
    - example : 
    int a = 5;  // In binary: 0101
        int b = 3;  // In binary: 0011
        System.out.println("Bitwise Operations between a = " + a + " and b = " + b);

        // Bitwise AND
        int andResult = a & b; // Result: 0001 (1 in decimal)
        System.out.println("Bitwise AND (a & b): " + andResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * 0011 (3 in binary)
         * -----
         * 0001 (1 in binary, result of a & b)
         */

        // Bitwise OR
        int orResult = a | b; // Result: 0111 (7 in decimal)
        System.out.println("Bitwise OR (a | b): " + orResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * 0011 (3 in binary)
         * -----
         * 0111 (7 in binary, result of a | b)
         */

        // Bitwise XOR
        int xorResult = a ^ b; // Result: 0110 (6 in decimal)
        System.out.println("Bitwise XOR (a ^ b): " + xorResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * 0011 (3 in binary)
         * -----
         * 0110 (6 in binary, result of a ^ b)
         */

        // Bitwise NOT
        int notResult = ~a; // Result: 1010 (in two's complement, -6 in decimal)
        System.out.println("Bitwise NOT (~a): " + notResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * -----
         * 1010 (inverted bits, which is -6 in two's complement)
         */

        // Left Shift
        int leftShiftResult = a << 1; // Result: 1010 (10 in decimal)
        System.out.println("Left Shift (a << 1): " + leftShiftResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * -----
         * 1010 (10 in binary, result of a << 1)
         */

        // Right Shift
        int rightShiftResult = a >> 1; // Result: 0010 (2 in decimal)
        System.out.println("Right Shift (a >> 1): " + rightShiftResult);
        /**
         * Explanation:
         * 0101 (5 in binary)
         * -----
         * 0010 (2 in binary, result of a >> 1)
         */
    5. Assignment Operators : = (Assign), += (Add and assign), -= (Subtract and assign), *= (Multiply and assign), /= (Divide and assign)
    - An assignment operator is one or two symbols that are used to assign a value to a variable.
    - example :
     int a = 10;
        int b = 5;

        System.out.println("Initial values: a = " + a + ", b = " + b);

        // Addition Assignment
        a += b; // Equivalent to a = a + b
        System.out.println("After a += b: a = " + a); // a = 15

        // Subtraction Assignment
        a -= b; // Equivalent to a = a - b
        System.out.println("After a -= b: a = " + a); // a = 10

        // Multiplication Assignment
        a *= b; // Equivalent to a = a * b
        System.out.println("After a *= b: a = " + a); // a = 50

        // Division Assignment
        a /= b; // Equivalent to a = a / b
        System.out.println("After a /= b: a = " + a); // a = 10

        // Modulus Assignment
        a %= b; // Equivalent to a = a % b
        System.out.println("After a %= b: a = " + a); // a = 0

=> Conditional Statements:-
- Conditions statements let you control the flow of your program - deciding which code runs, and which code is skipped.
- Every if statement needs a condition that results in true or false. 
-> if : The if statement specifies a block of code to be executed if a condition is true.
- example :
        int number = 15;

        // Simple If Statement
        if (number==15) {
            System.out.println("The number is exactly 15.");
        }
-> if-else :  The else statement lets you run a block of code when the condition in the if statement is false.
- example :
        // If-Else Statement
        if (number % 2 == 0) {
            System.out.println(number + " is an even number.");
        } else {
            System.out.println(number + " is an odd number.");
        }    
-> else-if (if-else Ladder) : Use the else if statement to specify a new condition if the first condition is false.
- example :     
        // If-Else Ladder
        if (number < 0) {
            System.out.println(number + " is a negative number.");
        } else if (number == 0) {
            System.out.println("The number is zero.");
        } else {
            System.out.println(number + " is a positive number.");
        }      
-> Nested If : You can also place an if statement inside another if. This is called a nested if statement.
- A nested if lets you check for a condition only if another condition is already true.
- example : 
        // Nested If Statement
        if (number > 0) {
            if (number < 10) {
                System.out.println(number + " is a positive single-digit number.");
            } else {
                System.out.println(number + " is a positive multi-digit number.");
            }
        } else {
            if (number < 0) {
                System.out.println(number + " is a negative number.");
            } else {
                System.out.println("The number is zero.");
            }
        }

=> Switch Case:-
-> Instead of writing many if..else statements, you can use the switch statement.
-> The switch statement selects one of many code blocks to be executed.
-> This is how it works:
    - The switch expression is evaluated once.
    - The result is compared with each case value.
    - If there is a match, the matching block of code runs.
    - The break statement stops the switch after the matching case has run.
    - A break can save a lot of execution time because it "ignores" the execution of all the rest of the code in the switch block.
    - The default statement runs if there is no match.
-> example :
            int day = 3; // Example day number
        String dayName;

        switch (day) {
            case 1:
                dayName = "Monday";
                break;
            case 2:
                dayName = "Tuesday";
                break;
            case 3:
                dayName = "Wednesday";
                break;
            case 4:
                dayName = "Thursday";
                break;
            case 5:
                dayName = "Friday";
                break;
            case 6:
                dayName = "Saturday";
                break;
            case 7:
                dayName = "Sunday";
                break;
            default:
                dayName = "Invalid day";
        }

        System.out.println("Day " + day + " is: " + dayName);

        /**
         * Explanation:
         * The switch statement evaluates the variable 'day'.
         * Based on its value, it matches one of the case labels (1 to 7).
         * When a match is found, the corresponding block of code is executed.
         * The 'break' statement prevents fall-through to subsequent cases .
         * If no case matches, the 'default' block is executed.
         * This is useful for replacing multiple if-else statements when checking a single variable against multiple values.
         */

=> Loops:-
-> While Loop:- The while loop repeats a block of code as long as the specified condition is true.
- Syntax:
    while (condition) {
     // code block to be executed
    }
- Do not forget to increase the variable used in the condition (i++), otherwise the loop will never end!    
-> example :
        int count = 1;
        System.out.println("While Loop Example:");
        // Using while loop to print numbers from 1 to 5
        while (count <= 10) {
            System.out.println("Count: " + count);
            count++;
        } 

-> Do While Loop:- The do/while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true. Then it will repeat the loop as long as the condition is true.
- Syntax:
    do {
      // code block to be executed
    } while (condition);   
- The semicolon ; after the while condition is required. 
-  A do/while loop always runs at least once, even if the condition is false at the start. This is the key difference from a while loop, which would skip the code block completely in the same situation.
- example :
      int count = 1;
        System.out.println("Do-While Loop Example:");
        // Using do-while loop to print numbers from 1 to 10
        do {
            System.out.println("Count: " + count);
            count++;
        } while (count <= 10);

-> For Loop:- Used when the number of iterations is known.
-> Syntax :
    for (initialization; condition; updation) {
     // code block to be executed
    } 
- initialization: executed (one time) before the execution of the code block.
- condition: defines the condition for executing the code block.
- updation: executed (every time) after the code block has been executed.     
- example :
     // Example of a for loop that prints numbers from 1 to 5
        System.out.println("For loop from 1 to 5:");
        for (int i = 1; i <= 5; i++) {
            System.out.println(i);
        }
        
- Nested For Loop: It is also possible to place a loop inside another loop. This is called a nested loop.   
- The "inner loop" will be executed one time for each iteration of the "outer loop".
- example :
    // nested for loop example
        System.out.println("Nested for loop (multiplication table 1 to 3):");
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                System.out.print(i * j + "\t");
            }
            System.out.println();
        }
        /**
         * Explanation:
         * The outer loop runs with 'i' taking values from 1 to 3.
         * For each value of 'i', the inner loop runs with 'j' taking values
         * from 1 to 3, printing the product of 'i' and 'j'.
         * This results in a multiplication table for numbers 1 to 3.
         */

-> Break Statement:- break statement to "jump out" of a switch statement.
- The break statement can also be used to jump out of a loop.
- example :
      for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                System.out.println("Breaking the loop when i is 3");
                break; // Exit the loop when i is 3
            }
            System.out.println(i);
        }
        /**
         * Explanation:
         * The loop starts with i = 1 and increments i by 1 in each iteration until i reaches 5.
         *  When i becomes 3, the break statement is executed, causing the loop to terminate immediately.
         * As a result, the numbers 1 and 2 are printed, but the loop stops before printing 3, 4, and 5.
         */
-> Continue Statement:- The continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.
- example :
    System.out.println("Demonstrating the continue statement in a for loop:");
        for (int i = 1; i <= 5; i++) {
            if (i == 3) {
                System.out.println("Continuing the loop when i is 3");
                continue; // Skip the rest of the loop when i is 3
            }
            System.out.println(i);
        }
        /**
         * Explanation:
            * The loop starts with i = 1 and increments i by 1 in each iteration until i reaches 5.
            * When i becomes 3, the continue statement is executed, causing the current iteration to skip the remaining code and move to the next iteration.
            * As a result, the numbers 1, 2, 4, and 5 are printed, but 3 is skipped.
         */
         
                                   
=> Functions(or Methods):-
-> A function is a block of code which only runs when it is called.
-> You can pass data, known as parameters, into a function.
-> function are used to perform certain actions.
-> functions are also known as Methods.
-> Syntax:
    public class Main {
        static void myFunction() {
        // code to be executed
     }
    }
-> Explanation:
- myFunction() is the name of the method
- static means that the method belongs to the Main class and not an object of the Main class. You will learn more about objects and how to access methods through objects later in this tutorial.
- void means that this method does not have a return value. You will learn more about return values later in this chapter     

-> types of functions:
(1) no argument, no return value:- function doesn't take argument nor returns value.
- example :
    /**
     * type of function: no argument, no return value
     * This function prints a greeting message to the console.
     */
    // type of function: no argument, no return value
    static void greet() {
        System.out.println("Hello, welcome to Java programming!");
    }
(2) with argument, with return value:- function takes argument and returns value.
- example :
    /**
     * type of function: with argument, with return value
     * This function takes two integers as arguments and returns their sum.
     * @param a First integer
     * @param b Second integer
     * @return Sum of a and b
     */

    //type of function: with argument, with return value
    static int add(int a, int b) {
        return a + b;
    }
(3) with argument, no return value:-  function takes argument and returns value, but doesn't returns values.
- example :    
    //type of function: with argument, no return value
    static void displaySum(int a, int b) {
        int sum = a + b;
        System.out.println("The sum is: " + sum);
    }
    /**
     * type of function: no argument, with return value
     * This function returns a greeting message.
     * @return Greeting message as a String
     */
(4) no argument with return value:- function doesn't take argument, but returns value.
- example :
       //type of function: no argument, with return value
    static String getGreetingMessage() {
        return "Hello, welcome to Java programming!";
    }
    /**
     * type of function: no argument with return value
     * This function returns a greeting message.
     * this function does not take any arguments but returns a String value.
     */

-> Other two types:- 
(1) Inbuilt-function: These are predefined in Java libraries and can be used directly.
- example :
(i) System.out.println() to print output to the console.
(ii) Math.sqrt() to calculate the square root of a number.
(iii) String.toLowerCase() to convert a string to lowercase. 

(2) User-Defined function: These are methods created by the programmer to perform specific tasks.
-example :
(i) Programmer create a function to calculate sum.
(ii) Programmer create a function to calculate factorial.

-> Function Overloading:- With function overloading, multiple function can have the same name with different parameters.
- Multiple functions can have the same name as long as the number and/or type of parameters are different.
- example :
    // Function to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Function to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Function to add two double values
    public double add(double a, double b) {
        return a + b;
    }

    public static void main(String[] args) {
        FunctionOverloading fo = new FunctionOverloading();

        // Calling the method with two integers
        System.out.println("Sum of 2 and 3: " + fo.add(2, 3));

        // Calling the method with three integers
        System.out.println("Sum of 1, 2 and 3: " + fo.add(1, 2, 3));

        // Calling the method with two double values
        System.out.println("Sum of 2.5 and 3.5: " + fo.add(2.5, 3.5));
    }
    /**
     * Output:
     * Sum of 2 and 3: 5
     * Sum of 1, 2 and 3: 6
     * Sum of 2.5 and 3.5: 6.0
     * Explanation:
     * In this example, we have three overloaded methods named 'add'.
     * The method that gets called depends on the number and type of arguments passed.
     * When we call 'add(2, 3)', the first method is invoked.
     * When we call 'add(1, 2, 3)', the second method is invoked.
     * When we call 'add(2.5, 3.5)', the third method is invoked.
     * This demonstrates function overloading in Java.
     * 
     */

=> Scope :-
-> Scope: variables are only accessible inside the region where they are created. This is called scope.
-> Metod Scope: Variables declared directly inside a method are available anywhere in the method following the line of code in which they were declared.
- example :
    public static void main(String[] args) {
        int outerVariable = 10; // This variable is in the scope of the main method

        {
            // This is a new block scope
            int innerVariable = 20; // This variable is in the scope of this block
            System.out.println("Inner Variable: " + innerVariable); // Accessible here
            System.out.println("Outer Variable from inner block: " + outerVariable); // Accessible here
        }

        // System.out.println("Inner Variable: " + innerVariable); // This would cause a compile-time error

        System.out.println("Outer Variable: " + outerVariable); // Accessible here
    }
-> Block Scope: A block of code refers to all of the code between curly braces { }. Variables declared inside a block of code are only accessible by the code between the curly braces, and only after the line in which the variable was declared.
- A block of code can stand alone, or be part of an if, while, or for statement. In a for loop, the variable declared in the loop header (like int i = 0) only exists inside the loop.
- example :
    public static void main(String[] args) {
        int x = 5; // Variable in the scope of the main method

        {
            // Start of a new block
            int y = 10; // Variable in the scope of this block
            System.out.println("Inside block:");
            System.out.println("x: " + x); // Accessible here
            System.out.println("y: " + y); // Accessible here
        } // End of the block

        System.out.println("Outside block:");
        System.out.println("x: " + x); // Accessible here
        // System.out.println("y: " + y); // This would cause a compile-time error
    }
-> Loop Scope: Variables declared inside a loop only exist inside the loop.
- example : 
     public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            int loopVariable = i * 2; // Variable in the scope of the loop
            System.out.println("Inside loop iteration " + i + ":");
            System.out.println("i: " + i); // Accessible here
            System.out.println("loopVariable: " + loopVariable); // Accessible here
        }

        // System.out.println("i: " + i); // This would cause a compile-time error
        // System.out.println("loopVariable: " + loopVariable); // This would also cause a compile-time error
    }

